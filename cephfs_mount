#!/usr/bin/env python3

"""
CephFS kernel mount tool.

(c) 2019 Jonas Jelten <jj@sft.mx>
Released under GPLv3 or later.

Can mount CephFS without the `mount.cephfs` helper tool,
instead, this is a pure-python implementation without any special dependencies.

If you want an even simpler variant without the kernel keyring, use:
    mount -t ceph -o name=client.username,secret=BASE64SECRET mon1,mon2,mon3:/path destination
"""

import argparse
import base64
import ctypes
import ctypes.util
import errno as errnos
import os
import socket
import sys


LIBC = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)
LIBC.mount.argtypes = (ctypes.c_char_p, ctypes.c_char_p,
                       ctypes.c_char_p, ctypes.c_ulong, ctypes.c_char_p)


def mount(source, target, filesystem, options=''):
    """
    Call the libc mount function.
    """
    mountflags = 0
    result = LIBC.mount(source, target, filesystem, mountflags, options)
    if result < 0:
        errno = ctypes.get_errno()
        raise OSError(
            errno,
            "Failed to mount %s with %s to %s with options '%s': %s; "
            "look at dmesg for details" % (source.decode(),
                                           filesystem.decode(),
                                           target.decode(),
                                           options.decode(),
                                           os.strerror(errno)))


def ceph_available():
    """
    Check if the kernel supports mounting ceph.
    """
    with open("/proc/filesystems") as hdl:
        for line in hdl:
            if line.strip() == 'nodev\tceph':
                return True
    return False


def resolve_mons(mon_str):
    """
    convert a string of monhost,monhost:port,...
    to monip,monip:port,...
    """

    mon_default_port = 6789

    mons = mon_str.split(",")
    resolved_mons = []
    for mon in mons:
        mon_split = mon.split(":", 1)
        mon_host = mon_split[0]
        mon_port = int(mon_split[1]) if len(mon_split) == 2 else mon_default_port

        print("testing connection to monitor %s:%d..." % (mon_host, mon_port), end="")
        sys.stdout.flush()
        try:
            conn_test = socket.socket()
            conn_test.settimeout(5)
            conn_test.connect((mon_host, mon_port))
            mon_ip = conn_test.getpeername()[0]
            conn_test.close()
            print(" ok.")
        except (TimeoutError, socket.timeout):
            print("\nfailed connection test to %s:%d" % (mon_host, mon_port))
            exit(1)

        mon_str = ":".join([mon_ip] + mon_split[1:])
        resolved_mons.append(mon_str)

    return ",".join(resolved_mons)


def upload_key(keyfile, keyid, username, nokeyring):
    """
    Read the given keyfile (which contains a base64-encoded shared secret)
    and upload it to the kernel keyring, if possible.

    If keyfile is none, a keyid for an already loaded secret keyid must be given.

    return the mount option that tells ceph about the secret id.
    """
    if keyfile:
        with open(keyfile) as hdl:
            key_b64 = hdl.read().strip()
            key = base64.b64decode(key_b64)
    else:
        key = None

    if not nokeyring:
        # add key to kernel keyring for the process keyring

        keyutils_libname = ctypes.util.find_library("keyutils")
        if not keyutils_libname:
            print("Could not find 'keyutils' library. You can try to use --nokeyring.")
            exit(1)

        # from keyutils.h
        key_serial_t = ctypes.c_int32
        key_spec_process_keyring = -2

        keyutils = ctypes.CDLL(keyutils_libname, use_errno=True)
        keyutils.add_key.restype = key_serial_t
        keyutils.add_key.argtypes = (
            ctypes.c_char_p,  # type
            ctypes.c_char_p,  # description
            ctypes.c_void_p,  # payload
            ctypes.c_size_t,  # payload_len
            key_serial_t,     # keyring
        )
        keyutils.request_key.restype = key_serial_t
        keyutils.request_key.argtypes = (
            ctypes.c_char_p,  # type
            ctypes.c_char_p,  # description
            ctypes.c_char_p,  # callout_info
            key_serial_t,     # keyring
        )

        if keyid:
            key_name = keyid
        else:
            key_name = "client.%s" % username

        if key:
            # push the key to the kernel
            serial = keyutils.add_key(b"ceph", key_name.encode(),
                                      key, len(key),
                                      key_spec_process_keyring)

            if serial == -1:
                errno = ctypes.get_errno()
                raise OSError(errno, "Failed to add key: %s" % (os.strerror(errno)))
        else:
            # verify the requested key exists
            # copy it to the process keyring
            serial = keyutils.request_key(b"ceph", key_name.encode(), None, 0)
            key_found = (serial != -1)
            if not key_found:
                print("Kernel probably does not know a ceph key with id='%s'" % key_name)

        return "key=%s" % key_name

    elif not keyfile:
        return None
    else:
        # legacy-way to pass the secret to the kernel
        return "secret=%s" % key_b64


def main():
    """
    Load the secret into the kernel and mount CephFS to the desired location.
    """
    cli = argparse.ArgumentParser()
    cli.add_argument("--nokeyring", action="store_true",
                     help="don't use the kernel keyring, pass the secret by commandline instead")
    cli.add_argument("--options", "-o",
                     help=("further comma-separated mount options like 'ro,relatime', "
                           "see 'man mount.cephfs'"))
    cli.add_argument("--keyfile", "-k",
                     help="file with the base64 encoded secret for authenticating the user")
    cli.add_argument("--keyid", "-i",
                     help="kernel keyring key id to use for authentication")
    cli.add_argument("--username", "-u", default=os.getlogin(),
                     help="ceph authentication username. default: %(default)s")
    cli.add_argument("--srcpath", "-s", default="/",
                     help="ceph source path to mount. default: %(default)s")
    cli.add_argument("--kernel-resolve", action="store_true",
                     help="let the kernel resolve the monitor IPs")
    cli.add_argument("monitors",
                     help=("commaseparated string of ceph monitor servers, e.g. mon1,mon2,mon3. "
                           "optionally, add :port for a monitor"))
    cli.add_argument("mount_destination",
                     help="path to destination director where to mount the ceph filesystem")

    args = cli.parse_args()

    if not (args.keyid or args.keyfile):
        cli.error("You need to specify a keyfile containing the base64 secret "
                  "or a keyid of an already loaded kernel secret")

    if os.geteuid() != 0:
        print("need root privileges")
        exit(1)

    if not ceph_available():
        print("Your kernel does not support mounting ceph filesystems. "
              "Is the ceph kernel module loaded?")
        exit(1)

    if args.kernel_resolve:
        monitors = args.monitors
    else:
        monitors = resolve_mons(args.monitors)

    key_option = upload_key(args.keyfile, args.keyid, args.username, args.nokeyring)
    if not key_option:
        print("Need --keyfile when not using an existing key in the kernel")
        exit(1)

    mnt_options = []
    mnt_options.append("name=%s" % args.username)
    mnt_options.append(key_option)
    if args.options:
        mnt_options.append(args.options)

    mnt_src = '%s:%s' % (monitors, args.srcpath)
    mnt_dst = args.mount_destination
    mnt_type = 'ceph'
    mnt_option_str = ",".join(mnt_options)

    print("mounting ceph from %s to %s..." % (mnt_src, mnt_dst))
    ret = mount(mnt_src.encode(),
                mnt_dst.encode(),
                mnt_type.encode(),
                mnt_option_str.encode())

    if ret != 0:
        errno = ctypes.get_errno()
        if errno == errnos.ENODEV:
            raise OSError(errno, ("failed to mount: ceph is not supported by system "
                                  "(is the kernel module loaded?)"))

        if errno != 0:
            raise OSError(errno, "failed to mount: %s" % (os.strerror(errno)))


if __name__ == "__main__":
    main()
